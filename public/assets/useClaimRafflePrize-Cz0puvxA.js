import{Bn as e,Hn as t,Kn as n,Pn as r,Yn as i,Zn as a,dt as o,ft as s,ht as c,ut as l}from"./index-B3aWA6vM.js";t();const u=()=>{let t=a(),{publicKey:u,sendTransaction:d}=r(),{checkAndInvalidateToken:f}=o(),p=async e=>{try{if(!u)throw Error(`Wallet not connected`);if(!await f(u.toBase58()))throw Error(`Signature verification failed`);if(!e)throw Error(`Raffle ID is required`);return!0}catch(e){return e instanceof Error?n.error(e.message):n.error(`Something went wrong`),!1}};return{claimPrize:i({mutationKey:[`claimPrize`],mutationFn:async t=>{if(!await p(t.raffleId))throw Error(`Validation failed`);let{base64Transaction:n,minContextSlot:r,blockhash:i,lastValidBlockHeight:a}=await c(t.raffleId.toString());console.log(`Received transaction from backend`,n);let o=Buffer.from(n,`base64`),u=await d(e.from(o),l,{minContextSlot:r});if((await l.confirmTransaction({blockhash:i,lastValidBlockHeight:a,signature:u})).value.err)throw Error(`Failed to claim prize`);let f=await s(t.raffleId.toString(),u);if(f.error)throw Error(f.error);return t.raffleId},onSuccess:e=>{t.invalidateQueries({queryKey:[`raffle`,e.toString()]}),t.invalidateQueries({queryKey:[`raffleWinnersWhoClaimedPrize`,e.toString()]}),n.success(`Prize claimed successfully`)},onError:e=>{console.error(e),e.message!==`Validation failed`&&n.error(`Failed to claim prize`)}})}};export{u as t};