import{En as e,Fn as t,Ln as n,Nn as r,bt as i,jn as a,lt as o,pt as s,rn as c,ut as l}from"./index-Cdx6LE6V.js";r();const u=()=>{let r=n(),{publicKey:u,sendTransaction:d}=e(),{checkAndInvalidateToken:f}=c(),p=async e=>{try{if(!u)throw Error(`Wallet not connected`);if(!await f(u.toBase58()))throw Error(`Signature verification failed`);if(!e)throw Error(`Raffle ID is required`);return!0}catch(e){return e instanceof Error?o.error(e.message):o.error(`Something went wrong`),!1}};return{claimPrize:t({mutationKey:[`claimPrize`],mutationFn:async e=>{if(!await p(e.raffleId))throw Error(`Validation failed`);let{base64Transaction:t,minContextSlot:n,blockhash:r,lastValidBlockHeight:o}=await s(e.raffleId.toString());console.log(`Received transaction from backend`,t);let c=Buffer.from(t,`base64`),u=await d(a.from(c),i,{minContextSlot:n});if((await i.confirmTransaction({blockhash:r,lastValidBlockHeight:o,signature:u})).value.err)throw Error(`Failed to claim prize`);let f=await l(e.raffleId.toString(),u);if(f.error)throw Error(f.error);return e.raffleId},onSuccess:e=>{r.invalidateQueries({queryKey:[`raffle`,e.toString()]}),r.invalidateQueries({queryKey:[`raffleWinnersWhoClaimedPrize`,e.toString()]}),o.success(`Prize claimed successfully`)},onError:e=>{console.error(e),e.message!==`Validation failed`&&o.error(`Failed to claim prize`)}})}};export{u as t};