import{Fn as e,Nn as t,On as n,Vn as r,dt as i,lt as a,mt as o,ut as s,xt as c,zn as l}from"./index-DL1tneOs.js";e();const u=()=>{let e=r(),{publicKey:u,sendTransaction:d}=n(),{checkAndInvalidateToken:f}=a(),p=async e=>{try{if(!u)throw Error(`Wallet not connected`);if(!await f(u.toBase58()))throw Error(`Signature verification failed`);if(!e)throw Error(`Raffle ID is required`);return!0}catch(e){return e instanceof Error?s.error(e.message):s.error(`Something went wrong`),!1}};return{claimPrize:l({mutationKey:[`claimPrize`],mutationFn:async e=>{if(!await p(e.raffleId))throw Error(`Validation failed`);let{base64Transaction:n,minContextSlot:r,blockhash:a,lastValidBlockHeight:s}=await o(e.raffleId.toString());console.log(`Received transaction from backend`,n);let l=Buffer.from(n,`base64`),u=await d(t.from(l),c,{minContextSlot:r});if((await c.confirmTransaction({blockhash:a,lastValidBlockHeight:s,signature:u})).value.err)throw Error(`Failed to claim prize`);let f=await i(e.raffleId.toString(),u);if(f.error)throw Error(f.error);return e.raffleId},onSuccess:t=>{e.invalidateQueries({queryKey:[`raffle`,t.toString()]}),e.invalidateQueries({queryKey:[`raffleWinnersWhoClaimedPrize`,t.toString()]}),s.success(`Prize claimed successfully`)},onError:e=>{console.error(e),e.message!==`Validation failed`&&s.error(`Failed to claim prize`)}})}};export{u as t};